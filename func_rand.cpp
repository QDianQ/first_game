#include "func_rand.h"
#include <stdlib.h>
#include <iostream>
#include <cstdlib>
#include <ctime>

// * В теле функции с памятью всё чисто, см main
void f_rand(int *buf,int size)     //функция для рандома чисел без повтора и записи в массив
{

    int tmp;    //переменная для рандомного числа
    int count=0;     //счетчик кол-ва совпадающих чисел в массиве

    srand(time(NULL));

    // * Часто используется size*size, логично завести переменную

    for (int i=0; i < (size*size); i++){    //логика функции предполагалась такой:
        tmp = 0 + rand() % (size*size);     //рандомится число

        // * Этим циклом нужно проходить только по УЖЕ заполненным элементам
        for(int j=0; j < (size*size); j++){     //далее цикл для сравнения рандомного числа tmp с каждым значением ячейки массива
            count=0; // * Этот счётчик не обязательно использовать (см ниже)
            if(buf[j]==tmp){                //условие: если число tmp совпадает с числом в ячейке, то инкрементировать count
                count++;
                // * Нет смысла продолжать, если есть хоть одно совпадение
                // * Вместо этого нужно сделать шаг назад по i и повторить попытку
            }
            // * Это условие можно заменить сравнением i и j
            if(count==0){                   //условие: если count равен нулю, тогда в ячейку массива присвоить значение tmp
                buf[i]=tmp;
                break;                      //и выйти из цикла сразу, как в ячейку было записано tmp
            }
        }
    }

    // * Вывод вспомогательной информации в stdout  это ок.
    // * Но нужно уметь это регулировать. Например c помощью #define + #ifdef
    // * Либо параметров функций. А в Qt есть специальные классы для этого QDebug, например. Но это позже
    // #ifdef SHOW_DEBUG_OUTPUT
    for (int i=0;i<size*size;i++)   //временный цикл для вывода на экран, чтобы убедиться в правильности формирования массива
        std::cout << buf[i] << std::endl;
    // #endif
}
